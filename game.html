<!DOCTYPE html>

<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<title></title>
        <script src="http://192.168.4.42:8080/socket.io/socket.io.js"></script>
        <script src="keydrown.js"></script>
        <script src="store.js"></script>
        <script src="8bit.js"></script>
        <script src="8bitplay.js"></script>
        <script src="../audio/gamesounds.js"></script>
        <script>
			// TODO: collision detection strategy - http://jsfiddle.net/DV9Bw/1/     http://stackoverflow.com/questions/6735470/get-pixel-color-from-canvas-on-mouseover

            // Global vars used throughout the game
            var canvas;
            var ctx;
            var playerPosX;
            var playerPosY;
            var triangleSideLength = 20;
            var playerColour = '#ff0000';
            var moveRate = 0;
            var moveSteps = 5;
            var moveAngle = 0;
            var angleSteps = 5;
            var keys = {};
            var player;
            var pulses = [];
            var mapOffsetX = 0;
            var mapOffsetY = 0;
            var playerMapPosition;
            var friction = 10;
            var map = {};
            map.width = 5000;
            map.height = 5000;
            var players = {};
            var mapArray = [];
            var startTime = Date.now();
            var lastScoreDisplayedTime = 0;
            var lastScoreDisplayed;
            var luck = 100;
            var socketId;
            var socket = io.connect('http://192.168.4.42:8080'),
                    username;
            var people;
            var worldItems = [];
            var colourCollisionRange = 4;
            var ded = false;
            var globalScoreThatJarredWillNeedToRefactor;
            var items = [];
            var myItems = [];


            // second canvas stuff
            var canvas0;
            var ctx0;
            var imgObj = new Image();
            imgObj.src = 'barbie.jpg';


            socket.on('connect', function() {
                if (! store.get('username')) {
                    username = prompt('What is your username?');
                    store.set('username', username);
                } else {
                    username = store.get('username');
                }

                var loginObject = {
                    username: username,
                    socketId: socketId,
                    version: '0.0.1'
                }

                socket.emit('connect', loginObject);
            });

            socket.on('updateOtherPlayers', function (data) {
//                log(data);
                switch (data.type) {
                    case 'moved' :
                        players[data.socketId].updateCoords(data.data.coords.x,data.data.coords.y,data.data.direction);
                        break;
                    case 'luckUpdate' :
                        players[data.socketId].updatePlayerState(data,false);
                        break;
                    case 'disconnected' :
                        players[data.socketId].shipSound.stop(); //@todo move this to a destructor function
                        delete players[data.socketId];
                        break;
                    case 'playerJoined' :
                        players[data.socketId] = new Player(data.data.coords.x,data.data.coords.y,data.data.colour,data.data.socketId, data.data.direction, data.data.username,data.data.luck);
                        break;
                    case 'dead' :
                        players[data.socketId].shipSound.stop(); //@todo move this to a destructor function
                        delete players[data.socketId];
                        break;
                }

            });

            function addWorldItem(type,colour) {

                worldItems.push({
                    type: type,
                    colour: colour.split(',')
                });

                return worldItems.length;

            }

            function removeWorldItem(pos) {
                worldItems = worldItems.splice(pos,1);
            }
            socket.on('worldEvents', function (data) {
                switch (data.type) {
                    case 'pulse' :
                        var pos = addWorldItem(data.type,data.data.colour);
                        pulses.push(new Pulse(data.data.mapX,data.data.mapY,data.data.colour, function(){
                            removeWorldItem(pos);
                        }));

                        gameSounds.get('pulse').at(data.data.mapX, data.data.mapY).fire();
                        break;
                }
            });

            socket.on('updateItems',function(data){
                log('yo got items dawg');
                items = data;
            });


            // update player
            socket.on('updatePlayer',function (data) {
                // Cody is sending through a type which we'll see what we need to do with it
                switch (data.type) {
                    case 'initialise' :
                        initialise(data);
                        break;
                    case 'luckUpdate' :
                        players[data.socketId].updatePlayerState(data,true);
                        break;
                    case 'updateItems' :
                        myItems.push(data);
                        break;
                    case 'dead' :
                        ded = true;
                        // TODO: reset score to 0
                        // Show a screen with scores and show a button that has 'Retry'
                        break;
                }

            });

            function initialise(data) {
                socketId = data.socketId;
                people = data.data;
                for (var key in people) {
                    if (! people.hasOwnProperty(key)) {
                        continue;
                    }

                    var p = people[key];
                    if(key == socketId) {
                        mapOffsetX = people[key].coords.vpx;
                        mapOffsetY = people[key].coords.vpy;
                        p.coords.x += people[key].coords.vpx;
                        p.coords.y += people[key].coords.vpy;
                    }
                    //log('socketId: ' + key);
                    players[key] = new Player(p.coords.x,p.coords.y,p.colour,key, p.direction, p.username, p.luck);
                }
            }

            /**
             * This is now used instead of setInterval();
             * It basically calls a function when it's ready, giving the browser time to catch
             * up if it's lagging behind. Before, with setInterval it would call a function before
             * it was ready to.
             */
            var requestAnimationFrame;
            (function() {
              requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
              window.requestAnimationFrame = requestAnimationFrame;
            })();

            /**
             * Standard initialising function
             * Sets up the canvas context, player position and
             * creates that player.
             *
             * Starts the update function which begins the game
             */
			function init() {

				// top canvas
                canvas = document.getElementById('canvas1');
                ctx = canvas.getContext('2d');

                // background canvas
				canvas0 = document.getElementById('canvas0');
				ctx0 = canvas0.getContext('2d');

                //these could be altered to the actual size of our map (i.e. 10000x10000)
                mapWidth = canvas0.width;
                mapHeight = canvas0.height;

                //sizes in pixels
                cellSize = 50;  //about twice the width to allow space to move
                wallChance = 10; //100 means entirely walls, 0 means no walls

                wallWidth = cellSize / 2;

                horizCells = mapWidth / cellSize;
                vertCells = mapHeight / cellSize;
                numberUnoccupied = 0;
                maxNumberUnoccupied = (horizCells - 2) * (vertCells - 2);
                wallColor = "rgb(255, 255, 255)";

                generateMap();

                playerPosX = canvas.width / 2;
                playerPosY = canvas.height / 2;

                // play the music
                //gameMusic.play();
                // when the browser is ready, we'll send it to update()
                requestAnimationFrame(update);
			}

            /**
             * This is called every animation frame, checks for new players
             * If there are, it will add them to the players array and
             * render will draw them
             */
            function update() {
                render();
                // once it has been display, display it again if when it's ready
                requestAnimationFrame(update);
            }



            function findObjectICollidedWith(coloursArray) {
                // loop through each worldItems array and check for the 3 matching colour values within a range of 4 either side
                for(var i=0;i<worldItems.length;i++) {

                    if(
                        (coloursArray[0] < worldItems[i].colour[0] + colourCollisionRange && coloursArray[0] > worldItems[i].colour[0] - colourCollisionRange) &&
                        (coloursArray[1] < worldItems[i].colour[1] + colourCollisionRange && coloursArray[1] > worldItems[i].colour[1] - colourCollisionRange) &&
                        (coloursArray[2] < worldItems[i].colour[2] + colourCollisionRange && coloursArray[2] > worldItems[i].colour[2] - colourCollisionRange)
                    ) {
                        // we have a hit
                        return worldItems[i];
                    }
                }
                return false;
            }


            /**
             * Player object
             * This will create the other players in the world
             * The name and positions will be sent through from Cody's server
             */


            function Pulse(px,py,colour,cb) {
                var pulse = {
                    transparency: 0.8,
                    lineWidth: 2,
                    myx: 2,
                    px: px,
                    py: py,
                    colour: colour,
                    draw: function() {
                        var lw = ctx.lineWidth;
                        var ss = ctx.strokeStyle;
                        var fs = ctx.fillStyle;
                        ctx.save();
                        ctx.translate(this.px + mapOffsetX,this.py + mapOffsetY);
                        ctx.beginPath();
                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = "rgba(" + this.colour +","+ this.transparency +")";
                        ctx.fillStyle = 'transparent';
                        ctx.arc(0, 0, this.myx*1.5, 0, Math.PI*2, false);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.lineWidth = lw;
                        ctx.strokeStyle = ss;
                        ctx.fillStyle = fs;
                        ctx.restore();
                    },
                    cb: cb
                };
                return pulse;
            }


            function Player(x,y,colour,id,direction,screenName,playerLuck) {

                var self = this;
                this.x = x;
                this.y = y;
                this.h = triangleSideLength;
                this.direction = direction;
                this.colour = colour;
                this.username = screenName;
                this.lastX = x;
                this.lastY = y;
                this.lastDirection = direction;
                this.mapX = x;
                this.mapY = y;
                this.luck = playerLuck;
                this.socketId = id;

                this.shipSound = gameSounds.get('buzz').start();

                this.draw = function() {

                    // have I been hit?
                    var p = ctx.getImageData(this.x, this.y, 1, 1).data;

                    var collidedObject = findObjectICollidedWith(p);

                    if(collidedObject !== false) {
                        // we hit something... let's return that object to cody
                        playerEvent({type: 'hit', data: collidedObject });
                    }

                    if(ded) {
                        ctx.beginPath();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'white';
                        ctx.fillText('You dedboi! you got: ' + globalScoreThatJarredWillNeedToRefactor,canvas.width / 2,canvas.height / 2);
                        ctx.font = '20px Lucida Console';

                        ctx.closePath();
                    }

                    ctx.save();
                    // move to the position of the triangle
                    if(socketId == this.socketId) {
                        this.mapY = this.y + Math.abs(mapOffsetY);
                        this.mapX = this.x + Math.abs(mapOffsetX);
                        ctx.translate(this.x,this.y);
                    } else {
                        // everyone else
                        ctx.translate(this.x + mapOffsetX,this.y + mapOffsetY);
                    }
                    // rotate it based on the keys pressed
                    ctx.rotate(Math.PI / 180 * this.direction);
                    // start our drawing of the triangle
                    ctx.beginPath();
                    ctx.moveTo(0,-this.h/2);
                    ctx.lineTo(-triangleSideLength/2, this.h/2);
                    ctx.lineTo(triangleSideLength/2,this.h/2);
                    ctx.lineTo(0,-this.h/2);
                    ctx.fillStyle = 'rgb(' + this.colour + ')';
                    ctx.fill();
                    ctx.closePath();
                    if(socketId != this.socketId) {
                        // draw the outline
                        ctx.strokeStyle = 'rgb(' + this.colour + ')';
                        ctx.stroke();
                    } else {
                        // draw the outline

                        var colourString = this.colour.split(',');

                        colourString[0] = 255 - colourString[0];
                        colourString[1] = 255 - colourString[1];
                        colourString[2] = 255 - colourString[2];
                        var myLineColour = colourString.join(',');

                        ctx.strokeStyle = 'rgb('+myLineColour+')';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    // draw circle on top of the triangle so we know which way it's facing
                    ctx.beginPath();
                    ctx.arc(0,-this.h/2,2,0,Math.PI*2,false);
                    ctx.fillStyle = 'rgb(' + this.colour + ')';
                    ctx.fill();
                    ctx.closePath();

                    if(socketId != this.socketId) {
                        // other players' luck bar
                        var r = 255 - (255 * (this.luck / 100));
                        var g = 255 * (this.luck / 100);
                        var b = 0;
                        if(this.luck > 0) {
                            ctx.beginPath();
                            ctx.fillStyle = 'rgba('+Math.floor(r)+','+Math.floor(g)+','+Math.floor(b)+',0.9)';
                            ctx.fillRect(this.h/2,0,3,-this.luck/6);
                            ctx.closePath();
                        }

                    }

                    // return the canvas to how it was
                    ctx.restore();

                    this.update();

                };
                this.updateCoords = function(x, y, direction) {
                    var yMovement;
                    if(typeof direction === 'undefined') {
                        yMovement = x;
                        direction = y;
                    }
                    if(socketId == this.socketId) {
                        if(yMovement) {
                            // reset the move rate so it only moves when a key is pressed
                            moveRate = 0;
                            // move viewport x axis
                            if(this.x > canvas.width - (Math.floor(canvas.width / 4)) && Math.abs(mapOffsetX) < map.width - canvas.width) {
                                // right hand side
                                if(yMovement < 0) {
                                    if(this.direction > 0 && this.direction < 180) {
                                        if(mapOffsetX > canvas.width - map.width) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetX += moveSteps * Math.sin(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetX = canvas.width - map.width;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                    }
                                } else {
                                    // I'm not allowing for players to reverse into the boundaries for the scrolling viewport... *sigh*
                                    if(this.direction < 360 && this.direction > 180) {
                                        if(mapOffsetX > canvas.width - map.width) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetX += moveSteps * Math.sin(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetX = canvas.width - map.width;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                    }
                                }
                            } else if(this.x < 0 + Math.floor((canvas.width / 4)) && mapOffsetX < 0) {
                                // left hand side
                                if(yMovement < 0) {
                                    if(this.direction < 360 && this.direction > 180) {
                                        if(mapOffsetX < 0) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetX -= moveSteps * Math.abs(Math.sin(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetX=0;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                    }
                                } else {
                                    if(this.direction > 0 && this.direction < 180) {
                                        if(mapOffsetX < 0) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetX += moveSteps * Math.abs(Math.sin(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetX=0;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                    }
                                }
                            } else if(this.x < this.h/2) {
                                // if going forward
                                if(yMovement < 0) {
                                    if(this.direction < 360 && this.direction > 180) {
                                        // we've reached the bounds of the map to the left and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        // this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                    }
                                } else {
                                    // backward
                                    if(this.direction > 0 && this.direction < 180) {
                                        // we've reached the bounds of the map to the left and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        //this.x += yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                    }
                                }
                            } else if(this.x > canvas.width - this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction > 0 && this.direction < 180) {
                                        // we've reached the bounds of the map to the right and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                    }
                                } else {
                                    if(this.direction < 360 && this.direction > 180) {
                                        // we've reached the bounds of the map to the right and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        // this.x += yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);

                                    }
                                }
                            } else {
                                if(this.direction < 360 && this.direction > 180) {
                                    this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                } else {
                                    this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                }
                            }
                            // viewport move y axis
                            // bottom
                            if(this.y > canvas.height - (Math.floor(canvas.height / 4)) && Math.abs(mapOffsetY) < map.height - canvas.height) {
                                if(yMovement < 0) {
                                    if(this.direction > 90 && this.direction < 270) {
                                        if(mapOffsetY > canvas.height - map.height) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetY += moveSteps * Math.abs(Math.cos(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetY=canvas.height - map.height;
                                        }

                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction < 90 || this.direction > 270) {
                                        if(mapOffsetY > canvas.height - map.height) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetY -= moveSteps * Math.abs(Math.cos(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetY=canvas.height - map.height;
                                        }
                                    } else {
                                        this.y -= yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y < 0 + Math.floor((canvas.height / 4)) && mapOffsetY < 0) {
                                if(yMovement < 0) {
                                    if(this.direction < 90 || this.direction > 270) {
                                        if(mapOffsetY < 0) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetY -= moveSteps * Math.cos(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetY=0;
                                        }
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction > 90 && this.direction < 270) {
                                        if(mapOffsetY < 0) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetY -= moveSteps * Math.cos(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetY=0;
                                        }
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y < this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction < 90 || this.direction > 270) {
                                        // we've reached the bounds of the map to the top and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction > 90 && this.direction < 270) {
                                        // we've reached the bounds of the map to the top and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y > canvas.height - this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction > 90 && this.direction < 270) {
                                        // we've reached the bounds of the map to the bottom and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction < 90 || this.direction > 270) {
                                        // we've reached the bounds of the map to the bottom and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else {
                                if(this.direction > 90 && this.direction < 270) {
                                    this.y += moveY(this.x,this.y,yMovement,direction,this.h/2,1);
                                } else {
                                    this.y += moveY(this.x,this.y,yMovement,direction,this.h/2,-1);
                                }
                            }
                        }
                    } else { //other players
                        this.x = x;
                        this.y = y;


                        this.shipSound.at(x, y);
                    }
                    this.direction = direction;
                };
				this.update = function() {

                    if(socketId == this.socketId) {
                        if(this.lastX == this.x && this.lastY == this.y && this.lastDirection == this.direction) {
                            return;
                        }
                        this.lastDirection = this.direction;
                        this.lastX = this.x;
                        this.lastY = this.y;

                        socket.emit('playerMoved', {
                            coords: {
                                x: this.mapX,
                                y: this.mapY,
                                vpx: mapOffsetX,
                                vpy: mapOffsetY
                            },
                            direction: this.direction
                        });

                        gameSounds.playerPosition(this.mapX, this.mapY, 0);
                    }
				};
                this.updatePlayerState = function(data,isMe) {
                    switch (data.type) {
                        case 'luckUpdate' :
                            if(isMe) {
                                log('testasdf');
                                luck = data.data;
                            } else {
                                this.luck = data.data;
                            }
                            break;
                        case 'itemsUpdate' :
                            items = data.data;
                            break;
                        // and so on and so forth
                    }

                };
            }

            function moveX(x,y,step,angle,height,multiplier) {
                blahX = x + Math.abs(mapOffsetX);
                blahX -= step * Math.sin(angle * Math.PI / 180) + ( (height + 1) * multiplier) ;
                y = y + Math.abs(mapOffsetY);
                var p = ctx0.getImageData(blahX, y, 1, 1).data;
                if(p[0] == 255) {
                    return 0;
                } else {
                    return step * Math.sin(angle * Math.PI / 180);
                }
            }

            function moveY(x,y,step,angle,height,multiplier) {
                blahY = y + Math.abs(mapOffsetY);
                blahY += step * Math.cos(angle * Math.PI / 180) + ( (height + 1) * multiplier) ;
                x = x + Math.abs(mapOffsetX);
                var p = ctx0.getImageData(x, blahY, 1, 1).data;
                if(p[0] == 255 && p[1] == 255 && p[2] == 255) {
                    return 0;
                } else {
                    return step * Math.cos(angle * Math.PI / 180);
                }
            }

            function displayScore() {

                if(!ded) {
                    var score = 'Score: ' + (Date.now() - startTime);

                    if(Date.now() - lastScoreDisplayedTime > 500) {
                        lastScoreDisplayedTime = Date.now();
                    } else{
                        score = lastScoreDisplayed;
                    }

                    var scoreOffsetX = canvas.width - 10;
                    ctx.beginPath();
                    ctx.fillStyle = 'white';
                    ctx.fillText(score,scoreOffsetX,20);
                    ctx.font = '20px Lucida Console';
                    ctx.textAlign = 'right';
                    ctx.closePath();
                    lastScoreDisplayed = score;

                    globalScoreThatJarredWillNeedToRefactor = score;
                }


            }
            function displayLuck() {
                var r = 255 - (255 * (luck / 100));
                var g = 255 * (luck / 100);
                var b = 0;
                ctx.fillStyle = 'rgba('+Math.floor(r)+','+Math.floor(g)+','+Math.floor(b)+',0.8)';
                ctx.fillRect(10,10,canvas.width * (luck / 400),20);
                document.getElementById('data').innerHTML = "<br> Yo luck: " + luck;
                for(var key in players) {
                    if(players[key].socketId != socketId) {
                        document.getElementById('data').innerHTML += "<br><span style=' color: rgb(" + players[key].colour + "); '>" + players[key].username + " - Luck: "+ players[key].luck + "</span>";
                    } else {
                        document.getElementById('data').innerHTML += "<br><span style=' color: rgb(" + players[key].colour + "); '>" + players[key].username + " - Luck: "+ luck + "</span>";
                    }

                }

            }
            function displayPulses() {
                // Do pulse here
                for(var i=0;i<pulses.length;i++) {
                    pulses[i].draw();
                    pulses[i].myx++;
                    pulses[i].transparency -= 0.01;
                    pulses[i].lineWidth += 0.05;

                    if(pulses[i].transparency < 0.02) {
                        if(typeof pulses[i].cb !== 'undefined') {
                            pulses[i].cb();
                        }
                        pulses.splice(0,1);
                    }
                }
            }
            function displayItems() {
                for(var i=0;i<items.length;i++) {
                    ctx.beginPath();
                    ctx.fillStyle = 'green';
                    ctx.fillRect(items[i].x,items[i].y,items[i].width,items[i].height);
                    ctx.closePath();

                }
            }

            /**
             *
             * render function
             * This is where the canvas is cleared and redrawn every frame
             * Players positions are updated through here
             */
            function render() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                // draw any pulses
                displayPulses();
                // draw the map with items
				ctx.save();
				ctx.translate(mapOffsetX,mapOffsetY);
                displayItems();
				ctx.restore();

                for(var key in players) {
                    if (!players.hasOwnProperty(key)) {
                        continue;
                    }
                    players[key].draw();
                }

                displayScore();
                displayLuck();


                canvas0.style.left = mapOffsetX + 'px';
                canvas0.style.top = mapOffsetY + 'px';

            }








            function drawBlock(x, y, width, color) {
                x = (x * cellSize) + wallWidth;
                y1 = (y * cellSize);
                y2 = (y+1) * cellSize;

                ctx0.lineWidth = width;
                ctx0.strokeStyle = color;
                ctx0.beginPath();
                ctx0.moveTo(x, y1);
                ctx0.lineTo(x, y2);
                ctx0.stroke();
            }

            function generateMap(){
                for (i=0; i<vertCells; i++){
                    subMapArray = new Array();
                    for (j=0; j<horizCells; j++){
                        if(i == 0 || i == vertCells-1 || j == 0 || j == horizCells-1){
                            //if it's a border, draw a wall
                            //drawBlock((j*cellSize)+wallWidth, (i*cellSize), (j*cellSize)+wallWidth, (i+1)*cellSize, wallWidth*2, wallColor);
                            drawBlock(j, i, wallWidth*2, wallColor);
                            subMapArray[j] = 1;
                        }else if(Math.random() > ((100-wallChance)/100)){
                            //otherwise, draw at random
                            //drawBlock((j*cellSize)+wallWidth, (i*cellSize), (j*cellSize)+wallWidth, (i+1)*cellSize, wallWidth*2, wallColor);
                            drawBlock(j, i, wallWidth*2, wallColor);
                            subMapArray[j] = 1;
                        }else{
                            //or don't
                            subMapArray[j] = 0;
                            numberUnoccupied++;
                        }
                    }
                    mapArray[i] = subMapArray;
                }
            }




































            /**
             * moveTriangle function
             * Sets up the key event handling
             * N.B. the event listener is on the <body> tag.
             * This should probably be moved
             */

            kd.LEFT.down(function(){
                players[socketId].lastX = players[socketId].x;
                players[socketId].lastDirection = players[socketId].direction;
                //moveAngle -= angleSteps;
                players[socketId].direction -= angleSteps;
                if(players[socketId].direction < 0) {
                    players[socketId].direction = 360 + players[socketId].direction;
                } else if(players[socketId].direction > 360) {
                    players[socketId].direction = players[socketId].direction - 360;
                }
                players[socketId].updateCoords(players[socketId].x,players[socketId].y,players[socketId].direction); // left
            });

            kd.RIGHT.down(function(){
                players[socketId].lastX = players[socketId].x;
                players[socketId].lastDirection = players[socketId].direction;
                players[socketId].direction += angleSteps;
                if(players[socketId].direction < 0) {
                    players[socketId].direction = 360 + players[socketId].direction;
                } else if(players[socketId].direction > 360) {
                    players[socketId].direction = players[socketId].direction - 360;
                }
                players[socketId].updateCoords(players[socketId].x,players[socketId].y,players[socketId].direction); // right

            });

            kd.UP.down(function(){
                if(!ded) {
                    players[socketId].lastY = players[socketId].y;
                    moveSteps = Math.abs(moveSteps) * -1;
                    players[socketId].updateCoords(moveSteps,players[socketId].direction);
                }
            });


            kd.DOWN.down(function(){
                // N.B. I've taken the down button out of the controls for the moment
                // because it was causing a bit of havoc and unneeded code for the collision
                // detection

//                players[socketId].lastY = players[socketId].y;
//                moveSteps = Math.abs(moveSteps);
//                players[socketId].updateCoords(moveSteps,players[socketId].direction);
            });

            kd.P.up(function(){
                // trigger pulse for player
                if(!ded) {
                    pulses.push(new Pulse(players[socketId].mapX,players[socketId].mapY,players[socketId].colour));
                    playerEvent({type: 'pulse',data: {mapX: players[socketId].mapX, mapY: players[socketId].mapY, colour: players[socketId].colour} });
                    gameSounds.get('pulse').at(players[socketId].mapX, players[socketId].mapY).fire();
                }
            });

            // This update loop is the heartbeat of Keydrown
            kd.run(function () {
                kd.tick();
            });

            function playerEvent(data) {
                socket.emit('worldEvent',data);
            }

			window.onload = init;

            function log(blah) {
                console.log(blah);
            }


        </script>
	</head>
	<body style="background: #2b2b2b;">
		<div id="wrap" style="position: relative;">
            <div style="width: 1000px; height: 500px; position: absolute; top: 0; left: 0; z-index: -1; overflow: hidden;">
                <canvas width="5000" height="5000" id="canvas0" style="position: absolute;"></canvas>
            </div>

            <canvas width="1000" height="500" id="canvas1" style="float: left; background: transparent;"></canvas>

            <span id="data" style="font-family: courier; font-size: 12px; color: white;"></span>
            <span id="theirdata" style="font-family: courier; font-size: 12px; color: white;"></span>
		</div>
	</body>
</html>