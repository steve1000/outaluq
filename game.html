<!DOCTYPE html>

<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<title></title>
        <script src="http://192.168.4.42:8080/socket.io/socket.io.js"></script>
        <script src="keydrown.js"></script>
        <script src="store.js"></script>
        <script src="8bit.js"></script>
        <script src="8bitplay.js"></script>
        <script>
			// TODO: collision detection strategy - http://jsfiddle.net/DV9Bw/1/     http://stackoverflow.com/questions/6735470/get-pixel-color-from-canvas-on-mouseover

            // Global vars used throughout the game
            var canvas;
            var ctx;
            var playerPosX;
            var playerPosY;
            var triangleSideLength = 20;
            var playerColour = '#ff0000';
            var moveRate = 0;
            var moveSteps = 5;
            var moveAngle = 0;
            var angleSteps = 5;
            var keys = {};
            var player;
            var pulses = [];
            var imgObj = new Image();
            imgObj.src = 'barbie.jpg';
            var mapOffsetX = 0;
            var mapOffsetY = 0;
            var playerMapPosition;
            var friction = 10;
            var map = {};
            map.width = 5000;
            map.height = 5000;
            var players = {};
            var mapArray = [];
            var startTime = Date.now();
            var lastScoreDisplayedTime = 0;
            var lastScoreDisplayed;
            var luck = 100;
            var socketId;
            var socket = io.connect('http://192.168.4.42:8080'),
                    username;
            var people;

            socket.on('connect', function() {
                if (! store.get('username')) {
                    username = prompt('What is your username?');
                    store.set('username', username);
                } else {
                    username = store.get('username');
                }

                var loginObject = {
                    username: username,
                    socketId: socketId
                }

                socket.emit('connect', loginObject);
            });

            socket.on('updateOtherPlayers', function (data) {
//                console.log(data);
                switch (data.type) {
                    case 'moved' :
                        players[data.socketId].updateCoords(data.data.coords.x,data.data.coords.y,data.data.direction);
                        break;
                    case 'luckUpdate' :
                        players[data.socketId].updatePlayerState(data,false);
                        break;
                    case 'disconnected' :
                        delete players[data.socketId];
                        break;
                    case 'playerJoined' :
                        players[data.socketId] = new Player(data.data.coords.x,data.data.coords.y,data.data.colour,data.data.socketId, data.data.direction, data.data.username);;
                }

            });

            socket.on('worldEvents', function (data) {
                switch (data.type) {
                    case 'pulse' :
                        pulses.push(new Pulse(data.data.mapX,data.data.mapY));
                        break;
                }
            });


            // update player
            socket.on('updatePlayer',function (data) {
                // Cody is sending through a type which we'll see what we need to do with it
                switch (data.type) {
                    case 'initialise' :
                            initialise(data);
                        break;
                    case 'luckUpdate' :
                        players[data.socketId].updatePlayerState(data,true);
                        break;
                    case 'dead' :
                        // TODO: reset score to 0
                        // Show a screen with scores and show a button that has 'Retry'
                        break;
                }

            });

            function initialise(data) {
                socketId = data.socketId;
                people = data.data;
                for (var key in people) {
                    if (! people.hasOwnProperty(key)) {
                        continue;
                    }

                    var p = people[key];
                    if(key == socketId) {
                        mapOffsetX = people[key].coords.vpx;
                        mapOffsetY = people[key].coords.vpy;
                        p.coords.x += people[key].coords.vpx;
                        p.coords.y += people[key].coords.vpy;
                    }
                    //console.log('socketId: ' + key);
                    players[key] = new Player(p.coords.x,p.coords.y,p.colour,key, p.direction, p.username);
                }
            }

            /**
             * This is now used instead of setInterval();
             * It basically calls a function when it's ready, giving the browser time to catch
             * up if it's lagging behind. Before, with setInterval it would call a function before
             * it was ready to.
             */
            var requestAnimationFrame;
            (function() {
              requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
              window.requestAnimationFrame = requestAnimationFrame;
            })();

            /**
             * Standard initialising function
             * Sets up the canvas context, player position and
             * creates that player.
             *
             * Starts the update function which begins the game
             */
			function init() {
				canvas = document.getElementById('canvas1');
				ctx = canvas.getContext('2d');

                playerPosX = canvas.width / 2;
                playerPosY = canvas.height / 2;

                // play the music
                gameMusic.play();
                // when the browser is ready, we'll send it to update()
                requestAnimationFrame(update);
			}


            // TODO: refer to these for scrolling viewport
            // http://jsfiddle.net/kmHZt/10/
            // http://jsfiddle.net/hKrrY/
            // http://jsfiddle.net/gfcarv/QKgHs/


            /**
             * This is called every animation frame, checks for new players
             * If there are, it will add them to the players array and
             * render will draw them
             */
            function update() {
                // get stuff from Cody
//                if (newPlayers()) {
//                     players.push(new Player(name,x,y,angle,colour));
//                }
                // display that stuff

                render();

                // once it has been display, display it again if when it's ready
                requestAnimationFrame(update);
                //setTimeout('update()',1000);
            }

            /**
             * Player object
             * This will create the other players in the world
             * The name and positions will be sent through from Cody's server
             */


            function Pulse(px,py) {
                var pulse = {
                    transparency: 0.8,
                    lineWidth: 2,
                    myx: 0,
                    px: px,
                    py: py,
                    draw: function() {
                        var lw = ctx.lineWidth;
                        var ss = ctx.strokeStyle;
                        var fs = ctx.fillStyle;
                        ctx.save();
                        ctx.translate(this.px + mapOffsetX,this.py + mapOffsetY);
                        ctx.beginPath();
                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = "rgba(31,151,204,"+ this.transparency +")";
                        ctx.fillStyle = 'transparent';
                        ctx.arc(0, 0, this.myx*1.5, 0, Math.PI*2, false);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.lineWidth = lw;
                        ctx.strokeStyle = ss;
                        ctx.fillStyle = fs;
                        ctx.restore();
                    }
                }
                return pulse;
            }


            function Player(x,y,colour,id,direction,screenName) {
                var self = this;
                this.x = x;
                this.y = y;
                this.h = triangleSideLength;
                this.direction = direction;
                this.colour = colour;
                this.username = screenName;
                this.lastX = x;
                this.lastY = y;
                this.lastDirection = direction;
                this.mapX = x;
                this.mapY = y;
                this.luck = null;
                this.socketId = id;

                this.draw = function() {

                    // have I been hit?
                    var p = ctx.getImageData(this.x, this.y, 1, 1).data;
                    if(p[3] < 255 && p[3] > 0) {
                        playerEvent({type: 'pulseHit'});
                        console.log(p);
                    } else {

                    }

                    ctx.save();
                    // move to the position of the triangle
                    if(socketId == this.socketId) {
                        this.mapY = this.y + Math.abs(mapOffsetY);
                        this.mapX = this.x + Math.abs(mapOffsetX);
                        ctx.translate(this.x,this.y);
                    } else {
                        // everyone else
                        ctx.translate(this.x + mapOffsetX,this.y + mapOffsetY);
                    }
                    // rotate it based on the keys pressed
                    ctx.rotate(Math.PI / 180 * this.direction);
                    // start our drawing of the triangle
                    ctx.beginPath();
                    ctx.moveTo(0,-this.h/2);
                    ctx.lineTo(-triangleSideLength/2, this.h/2);
                    ctx.lineTo(triangleSideLength/2,this.h/2);
                    ctx.lineTo(0,-this.h/2);
                    ctx.fillStyle = this.colour;
                    ctx.fill();
                    ctx.closePath();
                    // draw the outline
                    ctx.strokeStyle = this.colour;
                    ctx.stroke();
                    // draw circle on top of the triangle so we know which way it's facing
                    ctx.beginPath();
                    ctx.arc(0,-this.h/2,2,0,Math.PI*2,false);
                    ctx.fillStyle = this.colour;
                    ctx.fill();
                    ctx.closePath();

                    if(socketId != this.socketId) {

                        var r = 255 - (255 * (this.luck / 100));
                        var g = 255 * (this.luck / 100);
                        var b = 0;
                        ctx.beginPath();
                        ctx.fillStyle = 'rgba('+Math.floor(r)+','+Math.floor(g)+','+Math.floor(b)+',0.9)';
                        ctx.fillRect(this.h/2,0,3,-this.luck/6);
                        ctx.closePath();
                    }

                    // return the canvas to how it was
                    ctx.restore();

                    this.update();

                };
                this.updateCoords = function(x, y, direction) {
                    var yMovement;
                    if(typeof direction === 'undefined') {
                        yMovement = x;
                        direction = y;
                    }
                    if(socketId == this.socketId) {
                        if(yMovement) {
                            // reset the move rate so it only moves when a key is pressed
                            moveRate = 0;
                            // move viewport x axis
                            if(this.x > canvas.width - (Math.floor(canvas.width / 4)) && Math.abs(mapOffsetX) < map.width - canvas.width) {
                                // right hand side
                                if(yMovement < 0) {
                                    if(this.direction > 0 && this.direction < 180) {
                                        if(mapOffsetX > canvas.width - map.width) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetX += moveSteps * Math.sin(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetX = canvas.width - map.width;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                        log(1);
                                    }
                                } else {
                                    // I'm not allowing for players to reverse into the boundaries for the scrolling viewport... *sigh*
                                    if(this.direction < 360 && this.direction > 180) {
                                        if(mapOffsetX > canvas.width - map.width) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetX += moveSteps * Math.sin(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetX = canvas.width - map.width;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                        log(2);
                                    }
                                }
                            } else if(this.x < 0 + Math.floor((canvas.width / 4)) && mapOffsetX < 0) {
                                // left hand side
                                if(yMovement < 0) {
                                    if(this.direction < 360 && this.direction > 180) {
                                        if(mapOffsetX < 0) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetX -= moveSteps * Math.abs(Math.sin(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetX=0;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                        log(3);
                                    }
                                } else {
                                    if(this.direction > 0 && this.direction < 180) {
                                        if(mapOffsetX < 0) {
                                            if(moveX(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetX += moveSteps * Math.abs(Math.sin(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetX=0;
                                        }
                                    } else {
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                        log(4);
                                    }
                                }
                            } else if(this.x < this.h/2) {
                                // if going forward
                                if(yMovement < 0) {
                                    if(this.direction < 360 && this.direction > 180) {
                                        // we've reached the bounds of the map to the left and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        // this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                        log(5);
                                    }
                                } else {
                                    // backward
                                    if(this.direction > 0 && this.direction < 180) {
                                        // we've reached the bounds of the map to the left and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        //this.x += yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                        log(6);
                                    }
                                }
                            } else if(this.x > canvas.width - this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction > 0 && this.direction < 180) {
                                        // we've reached the bounds of the map to the right and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        //this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                        log(7);
                                    }
                                } else {
                                    if(this.direction < 360 && this.direction > 180) {
                                        // we've reached the bounds of the map to the right and we don't want to go any further
                                    } else {
                                        // change the x position based on the movement and angle
                                        // this.x += yMovement * Math.sin(direction * Math.PI / 180);
                                        this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                        log(8);
                                    }
                                }
                            } else {
                                if(this.direction < 360 && this.direction > 180) {
                                    this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,1);
                                    log(9);
                                } else {
                                    this.x -= moveX(this.x,this.y,yMovement,direction,this.h/2,-1);
                                    log(10);
                                }
                            }
                            // viewport move y axis
                            // bottom
                            if(this.y > canvas.height - (Math.floor(canvas.height / 4)) && Math.abs(mapOffsetY) < map.height - canvas.height) {
                                if(yMovement < 0) {
                                    if(this.direction > 90 && this.direction < 270) {
                                        if(mapOffsetY > canvas.height - map.height) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetY += moveSteps * Math.abs(Math.cos(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetY=canvas.height - map.height;
                                        }

                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction < 90 || this.direction > 270) {
                                        if(mapOffsetY > canvas.height - map.height) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetY -= moveSteps * Math.abs(Math.cos(direction * Math.PI / 180));
                                            }
                                        } else {
                                            mapOffsetY=canvas.height - map.height;
                                        }
                                    } else {
                                        this.y -= yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y < 0 + Math.floor((canvas.height / 4)) && mapOffsetY < 0) {
                                if(yMovement < 0) {
                                    if(this.direction < 90 || this.direction > 270) {
                                        if(mapOffsetY < 0) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,-1) != 0) {
                                                mapOffsetY -= moveSteps * Math.cos(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetY=0;
                                        }
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction > 90 && this.direction < 270) {
                                        if(mapOffsetY < 0) {
                                            if(moveY(this.x,this.y,yMovement,direction,this.h/2,1) != 0) {
                                                mapOffsetY -= moveSteps * Math.cos(direction * Math.PI / 180);
                                            }
                                        } else {
                                            mapOffsetY=0;
                                        }
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y < this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction < 90 || this.direction > 270) {
                                        // we've reached the bounds of the map to the top and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction > 90 && this.direction < 270) {
                                        // we've reached the bounds of the map to the top and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else if(this.y > canvas.height - this.h/2) {
                                if(yMovement < 0) {
                                    if(this.direction > 90 && this.direction < 270) {
                                        // we've reached the bounds of the map to the bottom and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                } else {
                                    if(this.direction < 90 || this.direction > 270) {
                                        // we've reached the bounds of the map to the bottom and we don't want to go any further
                                    } else {
                                        // change the y position based on the movement and angle
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }
                                }
                            } else {
                                if(this.direction > 90 && this.direction < 270) {
                                    this.y += moveY(this.x,this.y,yMovement,direction,this.h/2,1);
                                } else {
                                    this.y += moveY(this.x,this.y,yMovement,direction,this.h/2,-1);
                                }
                            }
                        }
                    } else {
                        this.x = x;
                        this.y = y;
                    }
                    this.direction = direction;
                };
				this.update = function() {

                    if(socketId == this.socketId) {
                        if(this.lastX == this.x && this.lastY == this.y && this.lastDirection == this.direction) {
                            return;
                        }
                        this.lastDirection = this.direction;
                        this.lastX = this.x;
                        this.lastY = this.y;

                        socket.emit('playerMoved', {
                            coords: {
                                x: this.mapX,
                                y: this.mapY,
                                vpx: mapOffsetX,
                                vpy: mapOffsetY
                            },
                            direction: this.direction
                        });
                    }
				};
                this.updatePlayerState = function(data,isMe) {
                    switch (data.type) {
                        case 'luckUpdate' :
                            if(isMe) {
                                luck = data.data;
                            } else {
                                this.luck = data.data;
                            }
                            break;
                        case 'itemsUpdate' :
                            items = data.data;
                            break;
                        // and so on and so forth
                    }

                };
            }

            function moveX(x,y,step,angle,height,multiplier) {
                blahX = x;
                blahX -= step * Math.sin(angle * Math.PI / 180) + ( (height + 1) * multiplier) ;
                var p = ctx.getImageData(blahX, y, 1, 1).data;
                if(p[0] == 255) {
                    return 0;
                } else {
                    return step * Math.sin(angle * Math.PI / 180);
                }
            }

            function moveY(x,y,step,angle,height,multiplier) {
                blahY = y;
                blahY += step * Math.cos(angle * Math.PI / 180) + ( (height + 1) * multiplier) ;
                var p = ctx.getImageData(x, blahY, 1, 1).data;
                if(p[0] == 255) {
                    return 0;
                } else {
                    return step * Math.cos(angle * Math.PI / 180);
                }
            }

            function displayScore() {

                var score = 'Score: ' + (Date.now() - startTime);

                if(Date.now() - lastScoreDisplayedTime > 500) {
                    lastScoreDisplayedTime = Date.now();
                } else{
                    score = lastScoreDisplayed;
                }

                var scoreOffsetX = canvas.width - 10;
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.fillText(score,scoreOffsetX,20);
                ctx.font = '20px Lucida Console';
                ctx.textAlign = 'right';
                ctx.closePath();
                lastScoreDisplayed = score;
            }
            function displayLuck() {
                var r = 255 - (255 * (luck / 100));
                var g = 255 * (luck / 100);
                var b = 0;
                ctx.fillStyle = 'rgba('+Math.floor(r)+','+Math.floor(g)+','+Math.floor(b)+',0.8)';
                ctx.fillRect(10,10,canvas.width * (luck / 400),20);
            }
            function displayPulses() {
                // Do pulse here
                for(var i=0;i<pulses.length;i++) {
                    pulses[i].draw();
                    pulses[i].myx++;
                    pulses[i].transparency -= 0.01;
                    pulses[i].lineWidth += 0.05;

                    if(pulses[i].transparency < 0.02) {
                        pulses.splice(0,1);
                    }
                }
            }
            /**
             *
             * render function
             * This is where the canvas is cleared and redrawn every frame
             * Players positions are updated through here
             */
            function render() {
                ctx.clearRect(0,0,canvas.width,canvas.height);

                ctx.fillStyle = "#181818";
                ctx.fillRect(0,0,canvas.width,canvas.height);
				ctx.save();
				ctx.translate(mapOffsetX,mapOffsetY);
                ctx.beginPath();
                ctx.fillStyle = 'ffffff';
                ctx.fillRect(150,150,100,100);
                ctx.fillRect(350,350,50,50);
                ctx.fillRect(750,750,50,50);
                ctx.arc(100,350,40,0,Math.PI*2,false);
                ctx.fill();
                ctx.closePath();
				//ctx.drawImage(imgObj,0,0);
				ctx.restore();

                displayPulses();

                for(var key in players) {
                    if (!players.hasOwnProperty(key)) {
                        continue;
                    }
                    players[key].draw();
                }

                displayScore();
                displayLuck();


//                document.getElementById('data').innerHTML = '<br>mapOffsetX: ' + mapOffsetX;
//                document.getElementById('data').innerHTML += '<br>mapOffsetY: ' + mapOffsetY;
//
//                document.getElementById('data').innerHTML += '<br>Player Map X: ' + mapOffsetX;
//                document.getElementById('data').innerHTML += '<br>Player Map Y: ' + mapOffsetY;

            }

            /**
             * moveTriangle function
             * Sets up the key event handling
             * N.B. the event listener is on the <body> tag.
             * This should probably be moved
             */

            kd.LEFT.down(function(){
                players[socketId].lastX = players[socketId].x;
                players[socketId].lastDirection = players[socketId].direction;
                //moveAngle -= angleSteps;
                players[socketId].direction -= angleSteps;
                if(players[socketId].direction < 0) {
                    players[socketId].direction = 360 + players[socketId].direction;
                } else if(players[socketId].direction > 360) {
                    players[socketId].direction = players[socketId].direction - 360;
                }
                players[socketId].updateCoords(players[socketId].x,players[socketId].y,players[socketId].direction); // left
            });

            kd.RIGHT.down(function(){
                players[socketId].lastX = players[socketId].x;
                players[socketId].lastDirection = players[socketId].direction;
                players[socketId].direction += angleSteps;
                if(players[socketId].direction < 0) {
                    players[socketId].direction = 360 + players[socketId].direction;
                } else if(players[socketId].direction > 360) {
                    players[socketId].direction = players[socketId].direction - 360;
                }
                players[socketId].updateCoords(players[socketId].x,players[socketId].y,players[socketId].direction); // right

            });

            kd.UP.down(function(){
                players[socketId].lastY = players[socketId].y;
                moveSteps = Math.abs(moveSteps) * -1;
                players[socketId].updateCoords(moveSteps,players[socketId].direction);

            });


            kd.DOWN.down(function(){
                // N.B. I've taken the down button out of the controls for the moment
                // because it was causing a bit of havoc and unneeded code for the collision
                // detection

//                players[socketId].lastY = players[socketId].y;
//                moveSteps = Math.abs(moveSteps);
//                players[socketId].updateCoords(moveSteps,players[socketId].direction);
            });

            kd.P.up(function(){
                // trigger pulse for player
                pulses.push(new Pulse(players[socketId].mapX,players[socketId].mapY));
                playerEvent({type: 'pulse',data: {mapX: players[socketId].mapX, mapY: players[socketId].mapY} });
            });

            // This update loop is the heartbeat of Keydrown
            kd.run(function () {
                kd.tick();
            });

            function playerEvent(data) {
                socket.emit('worldEvent',data);
            }

			window.onload = init;

            function log(blah) {
                //console.log(blah);
            }

		</script>
	</head>
	<body style="background: #2b2b2b;">
		<div id="wrap" style="position: relative;">
			<canvas width="1000" height="500" id="canvas1"></canvas>

            <span id="data" style="font-family: courier; font-size: 12px; color: white;"></span>
            <span id="theirdata" style="font-family: courier; font-size: 12px; color: white;"></span>
		</div>
	</body>
</html>