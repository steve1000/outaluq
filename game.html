<!DOCTYPE html>

<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<title></title>
        <script src="http://192.168.4.42:8080/socket.io/socket.io.js"></script>
        <script src="keydrown.js"></script>
        <script src="store.js"></script>
        <script>

            var players = {};

            var socket = io.connect('http://192.168.4.42:8080'),
                    username;

            socket.on('connect', function() {
                if (! store.get('username')) {
                    username = prompt('What is your username?');
                    store.set('username', username);
                } else {
                    username = store.get('username');
                }

                socket.emit('login', username);
            });

            socket.on('updatePeople', function(people) {
                for (var key in people) {
                    if (! people.hasOwnProperty(key)) {
                        continue;
                    }

                    if(!people[key].show) {
                        delete players[key];
                        continue;
                    }

                    var p = people[key];

                    if(typeof players[key] === 'undefined') {
                        var player = new Player(p.coords.x,p.coords.y,p.colour,key, p.direction);
                        players[key] = player;

                    } else {
                        players[key].updateCoords(p.coords.x, p.coords.y, p.direction);
                    }
                }
            });

            socket.on('updateThem', function (data) {
                console.log(data);
                players[data.username].updateCoords(data.coords.x,data.coords.y,data.direction);
            });

            /**
             * This is now used instead of setInterval();
             * It basically calls a function when it's ready, giving the browser time to catch
             * up if it's lagging behind. Before, with setInterval it would call a function before
             * it was ready to.
             */
            var requestAnimationFrame;
            (function() {
              requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
              window.requestAnimationFrame = requestAnimationFrame;
            })();

            // Global vars used throughout the game
            var canvas;
            var ctx;
            var playerPosX;
            var playerPosY;
            var triangleSideLength = 20;
            var playerColour = '#ff0000';
            var moveRate = 0;
            var moveSteps = 5;
            var moveAngle = 0;
            var angleSteps = 5;
            var keys = {};
            var player;
			var imgObj = new Image();
			imgObj.src = 'desert.jpg';
			var mapOffsetX = 0;
			var mapOffsetY = 0;
            var playerMapPosition;
            var friction = 10;

            /**
             * Standard initialising function
             * Sets up the canvas context, player position and
             * creates that player.
             *
             * Starts the update function which begins the game
             */
			function init() {
				canvas = document.getElementById('canvas1');
				ctx = canvas.getContext('2d');

                playerPosX = canvas.width / 2;
                playerPosY = canvas.height / 2;

                // when the browser is ready, we'll send it to update()
                requestAnimationFrame(update);
			}


            // TODO: refer to these for scrolling viewport
            // http://jsfiddle.net/kmHZt/10/
            // http://jsfiddle.net/hKrrY/
            // http://jsfiddle.net/gfcarv/QKgHs/


            /**
             * This is called every animation frame, checks for new players
             * If there are, it will add them to the players array and
             * render will draw them
             */
            function update() {
                // get stuff from Cody
//                if (newPlayers()) {
//                     players.push(new Player(name,x,y,angle,colour));
//                }
                // display that stuff

                render();

                // once it has been display, display it again if when it's ready
                requestAnimationFrame(update);
                //setTimeout('update()',1000);
            }

            /**
             * Player object
             * This will create the other players in the world
             * The name and positions will be sent through from Cody's server
             */
            function Player(x,y,colour,id,direction) {
                this.x = x;
                this.y = y;
                this.h = triangleSideLength;
                this.direction = direction;
                this.colour = colour;
                this.username = id;
                this.lastX = x;
                this.lastY = y;
                this.lastDirection = direction;

                this.draw = function() {

                    ctx.save();
                    // move to the position of the triangle
                    ctx.translate(this.x,this.y);
                    // rotate it based on the keys pressed
                    ctx.rotate(Math.PI / 180 * this.direction);
                    // start our drawing of the triangle
                    ctx.beginPath();
                    ctx.moveTo(0,-this.h/2);
                    ctx.lineTo(-triangleSideLength/2, this.h/2);
                    ctx.lineTo(triangleSideLength/2,this.h/2);
                    ctx.lineTo(0,-this.h/2);
                    ctx.fillStyle = this.colour;
                    ctx.fill();
                    ctx.closePath();
                    // draw the outline
                    ctx.strokeStyle = this.colour;
                    ctx.stroke();
                    // draw circle on top of the triangle so we know which way it's facing
                    ctx.beginPath();
                    ctx.arc(0,-this.h/2,2,0,Math.PI*2,false);
                    ctx.fillStyle = this.colour;
                    ctx.fill();
                    ctx.closePath();
                    // return the canvas to how it was
                    ctx.restore();

                    this.update();
                };
                this.updateCoords = function(x, y, direction) {
                    var yMovement;
                    if(typeof direction === 'undefined') {
                        yMovement = x;
                        direction = y;
                    }
                    if(username == this.username) {
                        if(yMovement) {

                            // reset the move rate so it only moves when a key is pressed
                            moveRate = 0;
                            // move viewport x axis
                            if(this.x > canvas.width - (Math.floor(canvas.width / 4))) {
                                // right hand side
                                if(yMovement < 0) {
                                    if(this.direction > 0 && this.direction < 180) {
                                        mapOffsetX+=moveSteps;
                                    } else {
                                        this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                    }

                                }
                            } else if(this.x < 0 + Math.floor((canvas.width / 4))) {
                                // left hand side
                                if(yMovement < 0) {
                                    if(this.direction < 360 && this.direction > 180) {
                                        mapOffsetX-=moveSteps;
                                    } else {
                                        this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                                    }

                                }
                            } else {
                                // change the x position based on the movement and angle
                                this.x -= yMovement * Math.sin(direction * Math.PI / 180);
                            }


                            // viewport move y axis
                            if(this.y > canvas.height - (Math.floor(canvas.height / 4))) {
                                if(yMovement < 0) {
                                    if(this.direction > 90 && this.direction < 270) {
                                        mapOffsetY+=moveSteps;
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }

                                }
                            } else if(this.y < 0 + Math.floor((canvas.height / 4))) {
                                if(yMovement < 0) {
                                    if(this.direction < 90 || this.direction > 270) {
                                        mapOffsetY-=moveSteps;
                                    } else {
                                        this.y += yMovement * Math.cos(direction * Math.PI / 180);
                                    }

                                }
                            } else {
                                // change the x position based on the movement and angle
                                this.y += yMovement * Math.cos(direction * Math.PI / 180);
                            }

                        }
                    } else {
                        this.x = x;
                        this.y = y;
                    }
                    this.direction = direction;
                };
				this.update = function() {

                    if(username == this.username) {
                        if(this.lastX == this.x && this.lastY == this.y && this.lastDirection == this.direction) {
                            return;
                        }
                        this.lastDirection = this.direction;
                        this.lastX = this.x;
                        this.lastY = this.y;

                        socket.emit('updateMe', {
                            username: username,
                            player: {
                                coords: {
                                    x: this.x,
                                    y: this.y
                                },
                                direction: this.direction
                            }
                        });
                    }
				};
            }

            /**
             *
             * render function
             * This is where the canvas is cleared and redrawn every frame
             * Players positions are updated through here
             */
            function render() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
				ctx.save();
				ctx.translate(mapOffsetX,mapOffsetY);
				ctx.drawImage(imgObj,0,0);
				ctx.restore();

                for(var key in players) {
                    if (!players.hasOwnProperty(key)) {
                        continue;
                    }
                    players[key].draw();

                }

            }

            /**
             * moveTriangle function
             * Sets up the key event handling
             * N.B. the event listener is on the <body> tag.
             * This should probably be moved
             */




            kd.LEFT.down(function(){
                console.log('helo');
                players[username].lastX = players[username].x;
                players[username].lastDirection = players[username].direction;
                //moveAngle -= angleSteps;
                players[username].direction -= angleSteps;
                if(players[username].direction < 0) {
                    players[username].direction = 360 + players[username].direction;
                } else if(players[username].direction > 360) {
                    players[username].direction = players[username].direction - 360;
                }
                players[username].updateCoords(players[username].x,players[username].y,players[username].direction); // left
            });

            kd.RIGHT.down(function(){
                players[username].lastX = players[username].x;
                players[username].lastDirection = players[username].direction;
                players[username].direction += angleSteps;
                if(players[username].direction < 0) {
                    players[username].direction = 360 + players[username].direction;
                } else if(players[username].direction > 360) {
                    players[username].direction = players[username].direction - 360;
                }
                players[username].updateCoords(players[username].x,players[username].y,players[username].direction); // right
            });

            kd.UP.down(function(){
                players[username].lastY = players[username].y;
                moveSteps = Math.abs(moveSteps) * -1;
                players[username].updateCoords(moveSteps,players[username].direction);
            });


            kd.DOWN.down(function(){
                players[username].lastY = players[username].y;
                moveSteps = Math.abs(moveSteps);
                players[username].updateCoords(moveSteps,players[username].direction);
            });

            // This update loop is the heartbeat of Keydrown
            kd.run(function () {
                kd.tick();
            });

			window.onload = init;

            function log(blah) {
                console.log(blah);
            }

		</script>
	</head>
	<body>
		<div id="wrap">
			<canvas width="500" height="500" id="canvas1"></canvas>
		</div>
	</body>
</html>